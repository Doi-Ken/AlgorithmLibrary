#include <string>
#include <sstream>
#include <random>
#include <iostream>
using namespace std;

struct Coord {
	int y_;
	int x_;
	Coord(const int y = 0, const int x = 0) : y_(y), x_(x){}
};

std::mt19937 mt_for_action(0); // 行動選択用の乱数生成器を初期化


constexpr const int H = 3; // 迷路の高さ
constexpr const int W = 4; // 迷路の幅
constexpr int END_TURN = 4; // ゲーム終了ターン


// 一人ゲームの例
// 1ターンに上下左右四方向のいずれかに1マスずつ進む。
// 床にあるポイントを踏むと自身のスコアとなり、床のポイントが消える。
// END_TURNの時点のスコアを高くすることが目的
class MazeState {
private:
	// 右、左、下、上への移動方向のx成分とy成分
	static constexpr const int dx[4] = { 1, -1, 0, 0 };
	static constexpr const int dy[4] = { 0, 0, 1, -1 };

	int points_[H][W] = {}; // 床のポイントを1-9で表現する
	int turn_ = 0; // 現在のターン

public:
	Coord character_ = Coord();
	int game_score_ = 0; // ゲーム上で実際に得たスコア
	MazeState() {}

	// h * wの迷路を生成する。
	MazeState(const int seed) {
		auto mt_for_construct = mt19937(seed); // 盤面構築用の乱数生成器を初期化
		this->character_.y_ = mt_for_construct() % H;
		this->character_.x_ = mt_for_construct() % W;

		for (int y = 0; y < H; y++) {
			for (int x = 0; x < W; x++) {
				if (y == character_.y_ && x == character_.x_) {
					continue;
				}
				this->points_[y][x] = mt_for_construct() % 10;
			}
		}

	}

	// [どのゲームでも実装する]：ゲームの終了判定
	bool isDone() const {
		return this->turn_ == END_TURN;
	}

	// [どのゲームでも実装する]：指定したactionでゲームを1ターン進める
	void advance(const int action) {
		this->character_.x_ += dx[action];
		this->character_.y_ += dy[action];
		auto& point = this->points_[this->character_.y_][this->character_.x_];
		if (point > 0) {
			this->game_score_ += point;
			point = 0;
		}
		this->turn_++;
	}


	// [どのゲームでも実装する]：現在の状況でプレイヤーが可能な行動すべてを取得する
	vector<int> legalActions() const {
		vector<int> actions;
		for (int action = 0; action < 4; action++) {
			int ty = this->character_.y_ + dy[action];
			int tx = this->character_.x_ + dx[action];
			if (ty >= 0 && ty < H && tx >= 0 && tx < W) {
				actions.emplace_back(action);
			}
		}
		return actions;
	}

	// [実装しなくても良いが実装すると便利]：現在のゲーム状況を文字列にする
	string toString() const {
		stringstream ss;
		ss << "turn:\t" << this->turn_ << endl;
		ss << "score:\t" << this->game_score_ << endl;

		for (int h = 0; h < H; h++) {
			for (int w = 0; w < W; w++) {
				if (this->character_.y_ == h && this->character_.x_ == w) {
					ss << '@';
				}
				else if (this->points_[h][w] > 0) {
					ss << points_[h][w];
				}
				else {
					ss << ".";
				}
			}
			ss << endl;
		}
		return ss.str();
	}


};

using State = MazeState;

// ランダムに行動を決定する
int randomAction(const State& state) {
	auto legal_actions = state.legalActions();

	return legal_actions[mt_for_action() % (legal_actions.size())];
}


// シードを指定してゲーム状況を表示しながらAIにプレイさせる。
void playGame(const int seed) {
	
	auto state = State(seed);
	cout << state.toString() << endl;

	while (!state.isDone()) {
		state.advance(randomAction(state));
		cout << state.toString() << endl;
	}
}

int main() {

	playGame(/*盤面初期化のシード*/ 121321);

	return 0;
}